---
description: Swift 文件事件监听扩展规则（当抛出事件时，必须为 View 添加 onXxx 监听方法）
globs: *.swift
alwaysApply: false
---
# Swift 文件事件监听扩展规则

本规则约束当 Swift 文件中抛出事件时，必须为 View 扩展添加相应的监听方法，提供便捷的事件监听 API。

## 核心原则

**当 Swift 文件通过 NotificationCenter 或其他方式抛出事件时，必须为 View 扩展添加一个以 `on` 开头的便捷监听方法。**

## 规则详情

### 1. 事件抛出规范

当在 Swift 文件中抛出事件时：

```swift
// ✅ 推荐：通过 NotificationCenter 发送通知
NotificationCenter.default.post(name: .customEvent, object: self)

// ✅ 推荐：使用 Combine PassthroughSubject
let eventSubject = PassthroughSubject<Void, Never>()
eventSubject.send()
```

### 2. View 扩展要求

**必须** 为每个抛出的事件添加对应的 View 扩展方法：

```swift
extension View {
    func onCustomEvent(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .customEvent)) { _ in
            action()
        }
    }
}
```

### 3. 方法命名规范

- **必须以 `on` 开头**：`onEventName`
- **驼峰命名法**：`onApplicationDidBecomeActive`
- **语义清晰**：方法名应清晰表达监听的事件类型
- **参数命名**：使用 `perform action` 参数名

### 4. 实现要求

#### NotificationCenter 事件监听

```swift
extension View {
    func onEventName(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .eventName)) { _ in
            action()
        }
    }
}
```

#### Combine Publisher 事件监听

```swift
extension View {
    func onEventName(_ publisher: some Publisher<Void, Never>, perform action: @escaping () -> Void) -> some View {
        self.onReceive(publisher) { _ in
            action()
        }
    }
}
```

### 5. 使用示例

```swift
struct MyView: View {
    var body: some View {
        Text("Hello")
            .onApplicationDidBecomeActive {
                // 监听应用变为活跃状态
                print("App became active!")
            }
            .onCustomEvent {
                // 监听自定义事件
                print("Custom event received!")
            }
    }
}
```

## 规则优势

### 1. 提升开发体验

- **语义化 API**：`onEventName` 比 `onReceive(notificationPublisher)` 更直观
- **减少样板代码**：避免在每个 View 中重复编写监听逻辑
- **类型安全**：编译时检查，无运行时错误风险

### 2. 统一代码风格

- **一致性**：所有事件监听都使用相同的命名模式
- **可维护性**：集中管理事件监听逻辑
- **可发现性**：IDE 自动补全 `onXxx` 方法

### 3. 最佳实践

- **解耦合**：View 不需要知道具体的 NotificationCenter 实现
- **可测试性**：事件监听逻辑独立，便于单元测试
- **可重用性**：扩展方法可在项目任何地方使用

## 注意事项

- **作用域**：扩展方法应放在抛出事件的同一个文件中，或相关工具文件中
- **命名冲突**：确保 `onXxx` 方法名在项目中唯一
- **线程安全**：确保事件监听在主线程执行 UI 更新操作
- **内存管理**：注意避免循环引用，特别是使用 Combine Publisher 时

## 常见模式

### 应用生命周期事件

```swift
extension View {
    func onApplicationDidBecomeActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .appDidBecomeActive)) { _ in
            action()
        }
    }

    func onApplicationWillBecomeActive(perform action: @escaping () -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .appWillBecomeActive)) { _ in
            action()
        }
    }
}
```

### 业务事件监听

```swift
extension View {
    func onProjectLoaded(perform action: @escaping (Project) -> Void) -> some View {
        self.onReceive(NotificationCenter.default.publisher(for: .projectLoaded)) { notification in
            if let project = notification.object as? Project {
                action(project)
            }
        }
    }
}
```

遵循此规则可以显著提升代码的可读性、可维护性和开发体验。